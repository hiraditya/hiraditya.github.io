<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Introduction to compiler toolchain! | Aditya Kumar</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Introduction to compiler toolchain!" />
<meta name="author" content="Aditya Kumar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="What is a compiler toolchain? Have you ever wondered what dependencies are required to compile a simple hello-world program? Even a small hello-world program needs a set of header files, and libraries that are used by the compiler. The header file e.g., iostream is required to find the declaration of functions which are not available in the hello-world program e.g, std::cout. The libraries are required to find definitions of functions e.g., std::operator« during the linkage process. As a result of the compilation process an executable is created runs on the machine." />
<meta property="og:description" content="What is a compiler toolchain? Have you ever wondered what dependencies are required to compile a simple hello-world program? Even a small hello-world program needs a set of header files, and libraries that are used by the compiler. The header file e.g., iostream is required to find the declaration of functions which are not available in the hello-world program e.g, std::cout. The libraries are required to find definitions of functions e.g., std::operator« during the linkage process. As a result of the compilation process an executable is created runs on the machine." />
<link rel="canonical" href="http://localhost:4000/compiler/2020/04/25/toolchain-description.html" />
<meta property="og:url" content="http://localhost:4000/compiler/2020/04/25/toolchain-description.html" />
<meta property="og:site_name" content="Aditya Kumar" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-25T19:11:59-07:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/compiler/2020/04/25/toolchain-description.html","dateModified":"2020-04-25T19:11:59-07:00","datePublished":"2020-04-25T19:11:59-07:00","headline":"Introduction to compiler toolchain!","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/compiler/2020/04/25/toolchain-description.html"},"author":{"@type":"Person","name":"Aditya Kumar"},"description":"What is a compiler toolchain? Have you ever wondered what dependencies are required to compile a simple hello-world program? Even a small hello-world program needs a set of header files, and libraries that are used by the compiler. The header file e.g., iostream is required to find the declaration of functions which are not available in the hello-world program e.g, std::cout. The libraries are required to find definitions of functions e.g., std::operator« during the linkage process. As a result of the compilation process an executable is created runs on the machine.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>
    <header>
      <div class="container">
          <h1>Introduction to compiler toolchain!</h1>
          <small>25 April 2020</small>
      </div>
    </header>
  
  
    <div class="container">
      <section id="main_content">
        <h1 id="what-is-a-compiler-toolchain">What is a compiler toolchain?</h1>
<p>Have you ever wondered what dependencies are required to compile a simple hello-world program? Even a small hello-world program needs a set of header files, and libraries that are used by the compiler. The header file e.g., iostream is required to find the declaration of functions which are not available in the hello-world program e.g, std::cout. The libraries are required to find definitions of functions e.g., std::operator« during the linkage process. As a result of the compilation process an executable is created runs on the machine.</p>

<h2 id="the-compilation-process">The compilation process</h2>
<p>When a compiler like g++ is used to compile a C++ program, the compilation process actually involves multiple steps depending on what output is desired. To see the steps involved in the compilation process -v needs to be passed to the compiler. We can use a small hello world program like the following to understand the compilation process:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world"</span><span class="p">;</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s inspect the output of the invocation of g++ compiler by enabling the verbose output. Although the verbose invocation outputs a lot of information, the relevant lines are the compiler invocation, the assembler invocation and the linker invocation. Didn’t I say just before that g++ hello.cpp was a compiler invocation? That is partially true because g++ is not a compiler, it is a compiler-driver. This may sound strange to many but that is true. The compiler in this case is cc1plus and the invocation is below.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>g++ hello.cpp <span class="nt">-v</span>
/usr/lib/gcc/x86_64-linux-gnu/7/cc1plus <span class="nt">-quiet</span> <span class="nt">-v</span> <span class="nt">-imultiarch</span> x86_64-linux-gnu <span class="nt">-D_GNU_SOURCE</span> hello.cpp <span class="nt">-quiet</span> <span class="nt">-dumpbase</span> hello.cpp <span class="nt">-mtune</span><span class="o">=</span>generic <span class="nt">-march</span><span class="o">=</span>x86-64 <span class="nt">-auxbase</span> hello <span class="nt">-version</span> <span class="nt">-fstack-protector-strong</span> <span class="nt">-Wformat</span> <span class="nt">-Wformat-security</span> <span class="nt">-o</span> /tmp/ccWH0EQc.s
...
GGC heuristics: <span class="nt">--param</span> ggc-min-expand<span class="o">=</span>100 <span class="nt">--param</span> ggc-min-heapsize<span class="o">=</span>131072
 ignoring duplicate directory <span class="s2">"/usr/include/x86_64-linux-gnu/c++/7"</span>
 ignoring nonexistent directory <span class="s2">"/usr/local/include/x86_64-linux-gnu"</span>
 ignoring nonexistent directory <span class="s2">"/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"</span>
 include <span class="s2">"…"</span> search starts here:
 include &lt;…&gt; search starts here:
 /usr/include/c++/7
 /usr/include/x86_64-linux-gnu/c++/7
...
</code></pre></div></div>

<p>As we can see from the command that the compiler compiles hello.cpp and outputs assembly code in the file <code class="highlighter-rouge">/tmp/ccWH0EQc.s</code>. During the compilation <strong>cc1plus</strong> needs to find the header file iostream which is present in <code class="highlighter-rouge">/usr/includec++/7</code></p>

<p>Next up is the assembler invocation. It reads the output of the compiler i.e., <code class="highlighter-rouge">/tmp/ccWH0EQc.s</code> and outputs an ‘object-file’ <code class="highlighter-rouge">/tmp/ccTpqU8Z.o</code>. The assembler does not have any dependencies.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/bin/x86_64-linux-gnu-as <span class="nt">-v</span> <span class="nt">--64</span> <span class="nt">-o</span> /tmp/ccTpqU8Z.o /tmp/ccWH0EQc.s
</code></pre></div></div>

<p>And lastly we have the linker invocation. The linker collect2 reads the output of assembler /tmp/ccTpqU8Z.o, an object file, and outputs the executable. The linker has a lot of dependencies. The most interesting ones are the runtime support files viz. <code class="highlighter-rouge">crt1.o, crti.o, crtendS.o crtn.o</code> and the standard libraries <code class="highlighter-rouge">libc, libgcc, libgcc_s, libm</code> etc. See if you can spot how these dependencies are passed to the linker. Now linker needs to know where these files are, actually the compiler-driver g++ needs to know where these files are such that it can invoke the linker with appropriate libraries (see the flags starting with -l) and appropriate paths (see the flags starting with <strong>-L</strong>).</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/lib/gcc/x86_64-linux-gnu/7/collect2 <span class="nt">-plugin</span> /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so <span class="nt">-plugin-opt</span><span class="o">=</span>/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper <span class="nt">-plugin-opt</span><span class="o">=</span><span class="nt">-fresolution</span><span class="o">=</span>/tmp/cc2j00rN.res <span class="nt">-plugin-opt</span><span class="o">=</span><span class="nt">-pass-through</span><span class="o">=</span><span class="nt">-lgcc_s</span> <span class="nt">-plugin-opt</span><span class="o">=</span><span class="nt">-pass-through</span><span class="o">=</span><span class="nt">-lgcc</span> <span class="nt">-plugin-opt</span><span class="o">=</span><span class="nt">-pass-through</span><span class="o">=</span><span class="nt">-lc</span> <span class="nt">-plugin-opt</span><span class="o">=</span><span class="nt">-pass-through</span><span class="o">=</span><span class="nt">-lgcc_s</span> <span class="nt">-plugin-opt</span><span class="o">=</span><span class="nt">-pass-through</span><span class="o">=</span><span class="nt">-lgcc</span> <span class="nt">--sysroot</span><span class="o">=</span>/ <span class="nt">--build-id</span> <span class="nt">--eh-frame-hdr</span> <span class="nt">-m</span> elf_x86_64 <span class="nt">--hash-style</span><span class="o">=</span>gnu <span class="nt">--as-needed</span> <span class="nt">-dynamic-linker</span> /lib64/ld-linux-x86-64.so.2 <span class="nt">-pie</span> <span class="nt">-z</span> now <span class="nt">-z</span> relro /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o <span class="nt">-L</span>/usr/lib/gcc/x86_64-linux-gnu/7 <span class="nt">-L</span>/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu <span class="nt">-L</span>/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib <span class="nt">-L</span>/lib/x86_64-linux-gnu <span class="nt">-L</span>/lib/../lib <span class="nt">-L</span>/usr/lib/x86_64-linux-gnu <span class="nt">-L</span>/usr/lib/../lib <span class="nt">-L</span>/usr/lib/gcc/x86_64-linux-gnu/7/../../.. /tmp/ccTpqU8Z.o <span class="nt">-lstdc</span>++ <span class="nt">-lm</span> <span class="nt">-lgcc_s</span> <span class="nt">-lgcc</span> <span class="nt">-lc</span> <span class="nt">-lgcc_s</span> <span class="nt">-lgcc</span> /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o
</code></pre></div></div>

<h2 id="sysroot">Sysroot</h2>
<p>Any compiler needs to know where the standard headers, standard libraries and the c-runtime are present. All of these are packaged together for each target e.g., arm64, x86 in a directory called ‘sysroot‘. When we compile a program we need to pass the path to sysroot for a compiler to know where to look for standard headers during compilation, and where to look for common libraries (libc, libstdc++ etc.) during linkage.</p>

<p>Normally when we compile a program for the same machine the compiler uses the standard headers available in ‘/usr/include‘ and libraries from ‘/usr/lib‘. These paths are hardcoded in the compiler itself so we never have to think about it. However, when building a custom compiler or when cross-compiling programs we have to tell the compiler where the sysroot is by passing a flag e.g. gcc –sysroot=”/path/to/arm64/sysroot/usr” hello.cpp. Most often pre-packaged cross compilers come with a script/binary that has ‘sysroot’ path embedded into it. e.g., aarch64-linux-gnu-gcc (https://packages.ubuntu.com/xenial/devel/gcc-aarch64-linux-gnu).</p>

<h2 id="the-compiler-toolchain">The compiler toolchain</h2>
<p>Apart from sysroot, a compiler toolchain contains various other binaries to help in the compilation process. In some cases the compiler itself comes as a part of the toolchain. Following is a list of items packaged with the toolchain.</p>

<ul>
  <li>binutils (assembler, linker etc)</li>
  <li>Various compilers (gcc, g++ etc.)</li>
  <li>C-Library (glibc, uClibc etc.)</li>
  <li>Runtime support libraries (crtbegin.o, crtend.o etc)</li>
  <li>debugger (gdb)</li>
  <li>C/C++ standard header files (iostream, stdio.h etc)</li>
  <li>standard libraries (libstdc++, libm, libgcc, libunwind etc.)</li>
  <li>Compiler specific header files (stdint.h, stdc-predef.h)</li>
  <li>Runtime support libraries for sanitizers (libasan, libubsan etc.)</li>
  <li>Not all of them may be present in all the toolchain depending on the toolchain provider. Here is the link to standard toolchains provided by popular vendors.</li>
</ul>

<h1 id="further-reading">Further Reading:</h1>
<p><a href="https://elinux.org/Toolchains">elinux</a></p>

      </section>

      
        <small>tags: <em>compiler</em> - <em>toolchains</em></small>
      
    </div>

    
  </body>
</html>